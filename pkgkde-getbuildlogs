#!/usr/bin/perl

use strict;
use warnings;

use Debian::PkgKde;
use Getopt::Long;
use File::Copy qw();
use File::Temp qw();
use File::Spec;
use IO::Uncompress::Inflate qw(inflate);

# Load extra modules (from libwww-perl and its dependencies)
BEGIN {
    eval "use HTTP::Request";
    if ($@) {
	error "in order to use this utility, you have to install libwww-perl package";
    }
}

use URI;
use URI::QueryParam;
use URI::Escape;
use HTTP::Response;
use LWP::UserAgent;
use HTML::LinkExtor;

sub usage {
    usageerr "[ -d destdir ] [ -v version ] [ -a arch ] [ -o ] [ package ] [ distribution ]";
}

sub construct_url {
    my ($path, %params) = @_;

    my $url = URI->new($path);
    foreach my $param (keys %params) {
	my @value = (ref $params{$param} eq "ARRAY") ?
	    @{$params{$param}} : ( $params{$param} );
	$url->query_param_append($param, @value);
    }
    return $url->as_string();
}

sub as_array {
    my $scalar = shift;
    my @ret;
    if (defined $scalar) {
	if (ref($scalar) eq 'ARRAY') {
	    @ret = @$scalar;
	} else {
	    push @ret, $scalar;
	}
    }
    return @ret;
}

sub get_command_output {
    my @lines;
    open(my $cmd, "-|", @_) or syserr("unable to execute command %s", $_[0]);
    while (<$cmd>) {
	chop;
	push @lines, $_;
    }
    close $cmd;
    return @lines;
}

sub get_rfc822_field_value {
    my ($field, $input) = @_;
    foreach my $line (@$input) {
	if ($line =~ /^\Q$field\E:\s*(.*)$/) {
	    return "$1"
	}
    }
}

sub download_logs {
    my ($destdir, $pkg, %opts) = @_;
    my $distro = $opts{distro};
    my $url;

    # Construct index URL
    if (defined $distro) {
        $url = construct_url('https://buildd.debian.org/pkg.cgi',
	    pkg => $pkg, dist => $distro, arch => [ as_array($opts{arch}) ]);
    } elsif (defined $opts{ver}) {
        $url = construct_url('https://buildd.debian.org/build.cgi',
	    pkg => $pkg, ver => [ as_array($opts{ver}) ],
	    arch => [ as_array($opts{arch}) ])
    } else {
	error "neither version(s) nor distribution was specified";
    }

    # Download index document and extract links
    info "Downloading build log index from $url ...";
    my $browser = LWP::UserAgent->new(
	agent => get_program_name(),
	timeout => 10,
	keep_alive => 1,
	env_proxy => 1,
    );
    my $request = HTTP::Request->new(GET => $url);
    if (my $response = $browser->request($request)) {
	error "unable to access log index at URL $url: ".$response->status_line
	    unless $response->is_success();
	my $linkextor = HTML::LinkExtor->new(undef, "https://buildd.debian.org/");
	$linkextor->parse($response->content());
	if (my @links = grep { $_->[0] eq "a" } $linkextor->links()) {
	    @links = map { shift @{$_}; +{ @{$_} }->{href} } @links;
	    my @ok;
	    my @failed;
	    foreach my $link (@links) {
		# Check if it is the link we need
		if ($link =~ m,/fetch\.cgi(\?[^/]+)$,) {
		    my $filename = $1 . ".build";
		    $filename =~ s/[?;&][^=]+=([^?;&]+)/_$1/g;
		    $filename =~ s/^_\.*//;
		    $filename = uri_unescape($filename);
		    my $file = File::Spec->catfile($destdir, $filename);

		    if ($opts{overwrite} || ! -e $file) {
			info "Fetching build log to $filename ...";
			$request = HTTP::Request->new(GET => $link);
			$request->header("Accept-Encoding" => "deflate, identity");
			$browser->show_progress(1);
			$response = $browser->request($request, $file);
			if ($response->is_success()) {
			    my $is_deflated = $response->header("Content-Encoding");
			    $is_deflated = defined $is_deflated && $is_deflated eq "deflate";
			    # Inflate contents if needed
			    if ($is_deflated) {
				my $inflatedfile = File::Temp->new(
				    TEMPLATE => $filename . ".XXXXXX"
				);
				if (inflate($file => $inflatedfile, BinModeOut => 1)) {
				    $inflatedfile->close();
				    File::Copy::move($inflatedfile->filename, $file) or
					error "unable to rename '%s' to '%s'",
					    $inflatedfile->filename, $file;
				    push @ok, [ $filename, "deflate" ];
				} else {
				    push @failed, [ $filename, "deflate" ];
				    unlink $filename;
				}
			    } else {
				push @ok, [ $filename ];
			    }
			} else {
			    push @failed, [ $filename ];
			}
		    } else {
			info "Not overwriting existing build log $filename ...";
			push @failed, [ $filename, "exists, ignored" ];
		    }
		}
	    }
	    return (@ok || @failed) ?  (\@ok, \@failed) : ();
	}
	return ();
    } else {
	error "unable to access log index URL $url";
    }
}

sub print_summary {
    my $logs = shift;
    my $is_warning = shift;
    my $msg = shift;
    if (@$logs) {
	info $msg, @_ unless $is_warning;
	warning $msg, @_ if $is_warning;
	foreach my $log_info (@$logs) {
	    my ($filename, $info) = @$log_info;
	    if (defined $info) {
		printmsg "  - %s [%s]", $filename, $info;
	    } else {
		printmsg "  - %s", $filename;
	    }
	}
    }
}

my $opt_destdir;
my @opt_versions;
my @opt_archs;
my $opt_force;

# Get and verify options
unless (GetOptions(
	"destdir|d=s" => \$opt_destdir,
	"version|v=s" => \@opt_versions,
	"arch|a=s" => \@opt_archs,
	"force|f!" => \$opt_force))
{
    usage();
}

my ($opt_package, $opt_distro) = @ARGV;
my @dpkg_parsechangelog;

if (!$opt_package && -f "debian/changelog") {
    @dpkg_parsechangelog = get_command_output("dpkg-parsechangelog");
    $opt_package = get_rfc822_field_value("Source", \@dpkg_parsechangelog);
}

if (!$opt_package) {
    errormsg "source package was not specified and could not be autoguessed";
    usage();
}

if ($opt_distro && @opt_versions) {
    errormsg "version and distribution options are mutually exclusive";
    usage();
}

if (!@opt_versions) {
    if (!$opt_distro && -f "debian/changelog") {
	@dpkg_parsechangelog = get_command_output("dpkg-parsechangelog") unless @dpkg_parsechangelog;
	$opt_distro = get_rfc822_field_value("Distribution", \@dpkg_parsechangelog);
	if ($opt_distro eq "UNRELEASED") {
	    # Get distro from the next to current entry
	    $opt_distro = get_rfc822_field_value("Distribution",
		[ get_command_output("dpkg-parsechangelog", "-c1", "-o1") ]);
	}
    }
    if (!$opt_distro) {
	errormsg "neither distribution nor version(s) was specified and could not be autoguessed";
	usage();
    }
}

# Determine destination directory to store logs
unless ($opt_destdir) {
    $opt_destdir = sprintf("%s_%s_logs", $opt_package,
	($opt_distro) ? $opt_distro : $opt_versions[0]);
}

info("Selected output directory for logs: %s/", $opt_destdir);
unless (-d $opt_destdir) {
    mkdir $opt_destdir;
}

my ($ok_logs, $failed_logs) =
    download_logs($opt_destdir, $opt_package, overwrite => $opt_force,
	distro => $opt_distro, ver => \@opt_versions, arch => \@opt_archs);

if (defined $ok_logs) {
    print_summary $ok_logs, 0, "Successfully downloaded build logs (stored to %s):", $opt_destdir;
    print_summary $failed_logs, 1, "Failed to fetch/ignored the following build logs:";
} else {
    error "no build logs referenced in the build log index";
}

END {
    rmdir $opt_destdir if $opt_destdir && $opt_destdir ne ".";
}

exit 0

# vim: noexpandtab tabstop=8 shiftwidth=4
