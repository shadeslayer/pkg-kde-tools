#!/usr/bin/perl -w

# Copyright (C) 2008-2010 Modestas Vainius <modax@debian.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

=head1 NAME

B<pkgkde-symbolshelper> - a helper tool for handling debian symbol files

=head1 SYNOPSIS

B<pkgkde-symbolshelper> U<subcommand> U<options>

=head1 DESCRIPTION

B<pkgkde-symbolshelper> is designed to ease maintainance of symbols files when
the package needs a different one for each architecture. This is especially true
for C++ libraries. However, differences in symbol names are usually minor and
can be defined using some rules for each architecture. The program also
introduces the concept of private symbols which, if actually exist, are written
to the final symbols file but, if do not exist, they are simply ignored
and do not cause failure at package build time.

B<pkgkde-symbolshelper> works by generating a template symbols file 

B<pkgkde-symbolshelper> U<symbolfile> subcommand should be called before
F<dpkg-gensymbols(1)> to generate a real symbols file from the template and
U<postgensymbols> subcommand should be called after F<dpkg-gensymbols(1)> to
post process the final symbols file that F<dpkg-gensymbols(1)> has generated.

Each subcommand accepts a few common options and a few specific options.

=head1 OPTIONS
=back

=cut

use strict;
use warnings;
use File::Spec;
use Getopt::Long;

use Dpkg::ErrorHandling;
use Dpkg::Arch qw(get_host_arch get_valid_arches);
use Debian::PkgKde::SymbolsHelper::SymbolFile;
use Debian::PkgKde::SymbolsHelper::SymbolFileCollection;

my $handlers;

######## Option processing ##################
my $opt_out;
my $opt_in;
my $opt_package;
my $opt_arch = get_host_arch();
my $opt_version;

sub verify_opt_arch {
    my ($opt, $arch) = @_;
    error("unknown architecture: $arch")
	unless grep /^\Q$arch\E$/, get_valid_arches();
    $opt_arch = $arch;
}

sub verify_opt_in {
    my ($opt, $input) = @_;

    error("input file ($input) does not exit") unless (-f $input);
    $opt_in = $input;
}

sub get_common_options {
    my $args = shift;
    my (%args, %res);

    map { $args{$_} = 1 } split(//, $args);
    $res{"output|o=s"} = \$opt_out if ($args{o});
    $res{"input|i=s"} = \&verify_opt_in if ($args{i});
    $res{"package|p=s"} = \$opt_package if ($args{p});
    $res{"architecture|a=s"} = \&verify_opt_arch if ($args{a});
    $res{"version|v:s"} = \$opt_version if ($args{v});

    return %res;
}

sub check_mandatory_options {
    my ($args, $msg, @opts) = @_;
    my %args;

    $msg = "" if (!defined $msg);
    map { $args{$_} = 1 } split(//, $args);
    error("input file option (-i) is mandatory $msg") if (!$opt_in && $args{i});
    error("output file option (-o) is mandatory $msg") if (!$opt_out && $args{o});
    error("package name option (-p) is mandatory $msg") if (!$opt_package && $args{p});
    error("architecture option (-a) is mandatory $msg") if (!$opt_arch && $args{a});
    error("version option (-v) is mandatory $msg") if (!$opt_version && $args{v});

    while (@opts) {
	my $val = shift @opts;
	my $msg = shift @opts;
	error($msg) if (!$val);
    }
    return 1;
}

############### Common subroutines #################
sub find_package_symbolfile_path {
    my ($package, $arch) = @_;
    my @PATHS = (
	"debian/$package.symbols.$arch",
	"debian/symbols.$arch",
	"debian/$package.symbols",
	"debian/symbols"
    );
    for my $path (@PATHS) {
	return $path if (-f $path);
    }
    return undef;
}

sub out_symfile {
    my $symfile = shift;
    return 1 unless $symfile;

    if ($opt_out) {
	$symfile->save($opt_out, template_mode => 1);
    } else {
	$symfile->dump(*STDOUT, template_mode => 1);
    }
    return 0;
}

sub print_symbol_list($$) {
    my ($list, $prefix) = @_;
    for my $item (@$list) {
	info(sprintf("%s%s %s\n", $prefix, $item->{soname}, $item->get_symbolname()));
    }
}

############### Subcommands ####################
sub subcommand_create {
    my $opt_dir;
    my %opts = (
	get_common_options("oav"),
	"directory|d=s" => \$opt_dir,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("", "",
	    $opt_dir => "symbol file directory option (-d) is mandatory");

	opendir(DIR, $opt_dir) or error("Unable to open directory: $opt_dir");
	my %files;
	my $str_arches = join("|", get_valid_arches());

	while (my $file = readdir(DIR)) {
	    next if ($file =~ /^.{1,2}$/);
	    $file = File::Spec->catfile($opt_dir, $file);
	    if ($file =~ /.*?[_.]($str_arches)$/) {
		$files{$1} = $file;
	    } else {
		warning("$file is not named properly. Expected *_<arch> or *.<arch>");
	    }
	}

	if (scalar(keys %files) > 0) {
	    # This one is needed by most subcommands
	    my $symfiles = Debian::PkgKde::SymbolsHelper::SymbolFileCollection->new($opt_arch);

	    $symfiles->load_symbol_files(\%files);
	    # Detect templinst symbols before substitutions
	    foreach my $symfile ($symfiles->get_symfiles()) {
		$symfile->mark_cpp_templinst_as_optional();
	    }

	    # Create a symbols template
	    my $template;
	    if (scalar(keys %files) == 1) {
		$template = $symfiles->create_template_standalone();
	    } else {
		$template = $symfiles->create_template();
	    }

	    $template->handle_min_version($opt_version);
	    $template->handle_virtual_table_symbols();
	    return out_symfile($template);
	} else {
	    error("no properly named symbol files found in $opt_dir");
	}
	return 0;
    }
    return 1;
}

sub subcommand_symbolfile {
    my %opts = (
	get_common_options("oipa"),
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i", "when package (-p) is not specified") unless ($opt_package);
	unless ($opt_in) {
	    $opt_in = "debian/$opt_package.symbols.in";
	    error("symbol template file '$opt_in' was not found for package '$opt_package'") unless (-r $opt_in);
	}
	# Redump to new location.
	my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(file => $opt_in, arch => $opt_arch);
	return out_symfile($symfile);
    }
    return 1;
}

sub subcommand_patch {
    error("NOT IMPLEMENTED YET");

    my $opt_diff;
    my %opts = (
	get_common_options("oipav"),
	"diff|d=s" => \$opt_diff,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i", "when package (-p) is not specified") unless ($opt_package);
	unless ($opt_in) {
	    $opt_in = "debian/$opt_package.symbols.in";
	    error("symbol template file '$opt_in' was not found for package '$opt_package'") unless (-r $opt_in);
	}
	$opt_out = $opt_in if (!$opt_out && -w $opt_in);

	$opt_diff = "-" unless ($opt_diff);
	# Open patch
	open(DIFFINPUT, $opt_diff) or error("unable to open patch '$opt_diff' for reading");
	my $ret = out_symfile($handlers->apply_patch_to_template(*DIFFINPUT, $opt_in, $opt_arch, $opt_version));
	close(DIFFINPUT);
	return $ret;
    }
    return 1;
}

sub subcommand_resort {
    my %opts = (
	get_common_options("oi"),
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i");

	if (-f $opt_in) {
	    my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(file => $opt_in, arch => $opt_arch);
	    return out_symfile($symfile);
	} else {
	    error("input symbol file ($opt_in) not found");
	    return 1;
	}
    }
    return 1;
}

sub subcommand_postgensymbols {
    warning("postgensymbols has been deprecated. Please remove this call.");
    return 1;
}

# Boilerplate for the common subcommand handler
sub subcommand_boilerplate {
    my %opts = (
	get_common_options("oipav"),
    );
    if (GetOptions(%opts)) {
#	 check_mandatory_options("o");
	return 0;
    }
    return 1;
}

my %SUBCOMMANDS = (
    "create"		=> [ 1, \&subcommand_create, "create symbol file template" ],
    "symbolfile"	=> [ 2, \&subcommand_symbolfile, "generate symbol file from the template" ],
    "patch"		=> [ 3, \&subcommand_patch, "apply dpkg-gensymbols patch to the symbol file template" ],
    "resort"		=> [ 4, \&subcommand_resort, "resort symbol file" ],
    "postgensymbols"	=> [ 5, \&subcommand_postgensymbols, "deprecated. Does nothing" ],
);

report_options(info_fh => \*STDERR);

my $curcmd = shift @ARGV;
if (defined $curcmd && exists $SUBCOMMANDS{$curcmd}) {
    my $ret = &{$SUBCOMMANDS{$curcmd}->[1]}();
    exit($ret);
} else {
    my $err;
    $err = ($curcmd) ? "unrecognized subcommand '$curcmd'." : "subcommand was not specified.";
    errormsg($err . " Valid subcommands are:");

    for my $cmd (sort({ $SUBCOMMANDS{$a}->[0] <=> $SUBCOMMANDS{$b}->[0] }
		 keys %SUBCOMMANDS)) {
	# Display command and its short help
	info("	$cmd - " . $SUBCOMMANDS{$cmd}->[2]);
    }
    exit(2);
}
