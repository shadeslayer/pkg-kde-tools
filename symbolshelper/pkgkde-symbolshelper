#!/usr/bin/perl -w

# Copyright (C) 2008-2010 Modestas Vainius <modax@debian.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

=head1 NAME

B<pkgkde-symbolshelper> - a helper tool for handling debian symbol files

=head1 SYNOPSIS

B<pkgkde-symbolshelper> U<subcommand> U<options>

=head1 DESCRIPTION

B<pkgkde-symbolshelper> is designed to ease maintainance of symbols files when
the package needs a different one for each architecture. This is especially true
for C++ libraries. However, differences in symbol names are usually minor and
can be defined using some rules for each architecture. The program also
introduces the concept of private symbols which, if actually exist, are written
to the final symbols file but, if do not exist, they are simply ignored
and do not cause failure at package build time.

B<pkgkde-symbolshelper> works by generating a template symbols file 

B<pkgkde-symbolshelper> U<symbolfile> subcommand should be called before
F<dpkg-gensymbols(1)> to generate a real symbols file from the template and
U<postgensymbols> subcommand should be called after F<dpkg-gensymbols(1)> to
post process the final symbols file that F<dpkg-gensymbols(1)> has generated.

Each subcommand accepts a few common options and a few specific options.

=head1 OPTIONS
=back

=cut

use strict;
use warnings;

# Setup environment
use constant DATADIR => '/usr/share/pkg-kde-tools';
BEGIN {
    my $datadir;
    if ($0 =~ m@^(.+)/[^/]+$@) {
	$datadir = $1;
    }
    if (!defined $datadir || ! -f "$datadir/Dpkg/Shlibs/SymbolFile.pm") {
	unshift @INC, DATADIR;
    }
}

use File::Spec;
use Getopt::Long;
use Dpkg::ErrorHandling;
use Dpkg::Arch qw(get_host_arch get_valid_arches);
use Debian::PkgKde::SymbolsHelper::SymbolFile;
use Debian::PkgKde::SymbolsHelper::SymbolFileCollection;
use Debian::PkgKde::SymbolsHelper::Patch;

######## Option processing ##################
my $opt_out;
my $opt_in;
my $opt_package;
my $opt_arch = get_host_arch();
my $opt_version;

sub verify_opt_arch {
    my ($opt, $arch) = @_;
    error("unknown architecture: $arch")
	unless grep /^\Q$arch\E$/, get_valid_arches();
    $opt_arch = $arch;
}

sub verify_opt_in {
    my ($opt, $input) = @_;

    error("input file ($input) does not exit") unless (-f $input);
    $opt_in = $input;
}

sub get_common_options {
    my $args = shift;
    my (%args, %res);

    map { $args{$_} = 1 } split(//, $args);
    $res{"output|o=s"} = \$opt_out if ($args{o});
    $res{"input|i=s"} = \&verify_opt_in if ($args{i});
    $res{"package|p=s"} = \$opt_package if ($args{p});
    $res{"architecture|a=s"} = \&verify_opt_arch if ($args{a});
    $res{"version|v:s"} = \$opt_version if ($args{v});

    return %res;
}

sub check_mandatory_options {
    my ($args, $msg, @opts) = @_;
    my %args;

    $msg = "" if (!defined $msg);
    map { $args{$_} = 1 } split(//, $args);
    error("input file option (-i) is mandatory $msg") if (!$opt_in && $args{i});
    error("output file option (-o) is mandatory $msg") if (!$opt_out && $args{o});
    error("package name option (-p) is mandatory $msg") if (!$opt_package && $args{p});
    error("architecture option (-a) is mandatory $msg") if (!$opt_arch && $args{a});
    error("version option (-v) is mandatory $msg") if (!$opt_version && $args{v});

    while (@opts) {
	my $val = shift @opts;
	my $msg = shift @opts;
	error($msg) if (!$val);
    }
    return 1;
}

############### Common subroutines #################
sub find_package_symbolfile_path {
    my ($package, $arch) = @_;
    my @PATHS = (
	"debian/$package.symbols.$arch",
	"debian/symbols.$arch",
	"debian/$package.symbols",
	"debian/symbols"
    );
    for my $path (@PATHS) {
	return $path if (-f $path);
    }
    return undef;
}

sub out_symfile {
    my ($symfile, %opts) = @_;
    return 1 unless $symfile;

    if ($opt_out) {
	$symfile->save($opt_out, template_mode => 1, %opts);
    } else {
	$symfile->dump(*STDOUT, template_mode => 1, %opts);
    }
    return 0;
}

sub tweak_symbol {
    my $sym = shift;

    $sym->handle_min_version($opt_version);
    $sym->handle_virtual_table_symbol();
}

############### Subcommands ####################
sub subcommand_create {
    my $opt_dir;
    my %opts = (
	get_common_options("oav"),
	"directory|d=s" => \$opt_dir,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("", "",
	    $opt_dir => "symbol file directory option (-d) is mandatory");

	opendir(DIR, $opt_dir) or error("Unable to open directory: $opt_dir");
	my %files;
	my $str_arches = join("|", get_valid_arches());

	while (my $file = readdir(DIR)) {
	    next if ($file =~ /^.{1,2}$/);
	    $file = File::Spec->catfile($opt_dir, $file);
	    if ($file =~ /.*?[_.]($str_arches)$/) {
		$files{$1} = $file;
	    } else {
		warning("$file is not named properly. Expected *_<arch> or *.<arch>");
	    }
	}

	if (scalar(keys %files) > 0) {
	    # This one is needed by most subcommands
	    my $symfiles = Debian::PkgKde::SymbolsHelper::SymbolFileCollection->new($opt_arch);

	    $symfiles->load_symbol_files(\%files);
	    # Detect templinst symbols before substitutions
	    # Do not mark as optional yet to avoid inteferring with template
	    # creation.
	    foreach my $symfile ($symfiles->get_symfiles()) {
		foreach my $sym ($symfile->get_symbols()) {
		    $sym->mark_cpp_templinst_as_optional("to-be-templinst");
		}
	    }

	    # Create a symbols template
	    my $template;
	    if (scalar(keys %files) == 1) {
		$template = $symfiles->create_template_standalone();
	    } else {
		$template = $symfiles->create_template();
	    }

	    foreach my $sym ($template->get_symbols()) {
		# Set standard optional=templinst tag where scheduled
		if ($sym->has_tag("to-be-templinst")) {
		    $sym->delete_tag("to-be-templinst");
		    $sym->add_tag("optional", "templinst") unless $sym->is_optional();
		}
		tweak_symbol($sym);
	    }
	    return out_symfile($template);
	} else {
	    error("no properly named symbol files found in $opt_dir");
	}
	return 0;
    }
    return 1;
}

sub subcommand_patch {
    my $opt_diff;
    my %opts = (
	get_common_options("oipav"),
	"diff|d=s" => \$opt_diff,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i", "when package (-p) is not specified") unless ($opt_package);
	unless ($opt_in) {
	    $opt_in = find_package_symbolfile_path($opt_package, $opt_arch);
	    error("symbol template file was not found for package '$opt_package'")
		unless (defined $opt_in && -r $opt_in);
	}
	$opt_out = $opt_in if (!$opt_out && -w $opt_in);
	$opt_diff = "-" unless ($opt_diff);

	# Open patch
	open(DIFFINPUT, $opt_diff)
	    or error("unable to open patch '$opt_diff' for reading");

	my $orig_symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(
	    file => $opt_in, arch => $opt_arch);
	my $patched_symfile = patch_symbolfile($opt_in, *DIFFINPUT);

	# Read remaning $patchfh stream
	if ($opt_diff eq "-") {
	    while (<DIFFINPUT>) {}
	}
	close(DIFFINPUT);

	error("supplied patch does not apply to the symbols file '$opt_in'")
	    unless defined $patched_symfile;

	foreach my $info ($patched_symfile->get_new_symbols($orig_symfile)) {
	    # Retrieve real symbol instance
	    my $sym = $patched_symfile->{objects}{$info->{soname}}{syms}{$info->get_symbolname()};
	    $sym->mark_cpp_templinst_as_optional();
	    tweak_symbol($sym);

	    info("NEW symbol: " . $sym->get_symbolspec(1));
	}
	return out_symfile($patched_symfile);
    }
    return 1;
}

sub subcommand_resort {
    my $opt_template = 1;
    my %opts = (
	get_common_options("oia"),
	"template!" => \$opt_template,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i");

	if (-f $opt_in) {
	    my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(file => $opt_in, arch => $opt_arch);
	    my %o = (
		template_mode => $opt_template
	    );
	    return out_symfile($symfile, %o);
	} else {
	    error("input symbol file ($opt_in) not found");
	    return 1;
	}
    }
    return 1;
}

sub subcommand_symbolfile {
    warning("'symbolfile' and debian/*.symbols.in files have been deprecated.");
    info("You should add substitutions to standard symbol files and " .
         "use pkgkde-gensymbols as dpkg-gensymbols wrapper.");
    my %opts = (
	get_common_options("oipa"),
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i", "when package (-p) is not specified") unless ($opt_package);
	unless ($opt_in) {
	    $opt_in = "debian/$opt_package.symbols.in";
	    error("symbol template file '$opt_in' was not found for package '$opt_package'") unless (-r $opt_in);
	}
	# Redump to new location.
	my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(file => $opt_in, arch => $opt_arch);
	foreach my $sym ($symfile->get_symbols()) {
	    if ($sym->has_tag("subst")) {
		my $val = $sym->get_tag_value("subst");
		if (defined $val && $val eq "compat") {
		    # Reset symbol template to current name value
		    $sym->set_symbolname();
		    $sym->delete_tag("subst");
		}
	    }
	}
	return out_symfile($symfile);
    }
    return 1;
}

sub subcommand_postgensymbols {
    warning("postgensymbols has been deprecated. Please remove this call.");
    return 0;
}

# Boilerplate for the common subcommand handler
sub subcommand_boilerplate {
    my %opts = (
	get_common_options("oipav"),
    );
    if (GetOptions(%opts)) {
#	 check_mandatory_options("o");
	return 0;
    }
    return 1;
}

my %SUBCOMMANDS = (
    "create"		=> [ 1, \&subcommand_create, "create symbol file template" ],
    "patch"		=> [ 2, \&subcommand_patch, "apply dpkg-gensymbols patch to the symbol file template" ],
    "resort"		=> [ 3, \&subcommand_resort, "resort symbol file" ],
    "symbolfile"	=> [ 4, \&subcommand_symbolfile, "deprecated by pkgkde-gensymbols wrapper" ],
    "postgensymbols"	=> [ 5, \&subcommand_postgensymbols, "deprecated. Does nothing" ],
);

report_options(info_fh => \*STDERR);

my $curcmd = shift @ARGV;
if (defined $curcmd && exists $SUBCOMMANDS{$curcmd}) {
    my $ret = &{$SUBCOMMANDS{$curcmd}->[1]}();
    exit($ret);
} else {
    my $err;
    $err = ($curcmd) ? "unrecognized subcommand '$curcmd'." : "subcommand was not specified.";
    errormsg($err . " Valid subcommands are:");

    for my $cmd (sort({ $SUBCOMMANDS{$a}->[0] <=> $SUBCOMMANDS{$b}->[0] }
		 keys %SUBCOMMANDS)) {
	# Display command and its short help
	info("	$cmd - " . $SUBCOMMANDS{$cmd}->[2]);
    }
    exit(2);
}
