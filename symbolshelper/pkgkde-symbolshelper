#!/usr/bin/perl -w

# Copyright (C) 2008-2010 Modestas Vainius <modax@debian.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

use strict;
use warnings;

# Setup environment
use constant DATADIR => '/usr/share/pkg-kde-tools';
BEGIN {
    my $datadir;
    if ($0 =~ m@^(.+)/[^/]+$@) {
	$datadir = $1;
    }
    if (!defined $datadir || ! -f "$datadir/Dpkg/Shlibs/SymbolFile.pm") {
	unshift @INC, DATADIR;
    }
}

use File::Spec;
use File::Basename qw();
use Getopt::Long qw(:config noignore_case);
use Dpkg::ErrorHandling;
use Dpkg::Arch qw(get_host_arch get_valid_arches);
use Dpkg::Version;
use Dpkg::IPC;
use Debian::PkgKde::SymbolsHelper::SymbolFile;
use Debian::PkgKde::SymbolsHelper::SymbolFileCollection;
use Debian::PkgKde::SymbolsHelper::Patching;

######## Option processing ##################
my $opt_out;
my $opt_in;
my $opt_package;
my $opt_arch = get_host_arch();
my $opt_version;
my $opt_verbose;

sub verify_opt_arch {
    my ($opt, $arch) = @_;
    error("unknown architecture: $arch")
	unless grep /^\Q$arch\E$/, get_valid_arches();
    $opt_arch = $arch;
}

sub verify_opt_in {
    my ($opt, $input) = @_;

    error("input file ($input) does not exit") unless (-f $input);
    $opt_in = $input;
}

sub get_common_options {
    my $args = shift;
    my (%args, %res);

    map { $args{$_} = 1 } split(//, $args);
    $res{"output|o=s"} = \$opt_out if ($args{o});
    $res{"input|i=s"} = \&verify_opt_in if ($args{i});
    $res{"package|p=s"} = \$opt_package if ($args{p});
    $res{"architecture|a=s"} = \&verify_opt_arch if ($args{a});
    $res{"version|v:s"} = \$opt_version if ($args{v});
    $res{"verbose|V!"} = \$opt_verbose if ($args{V});

    return %res;
}

sub check_mandatory_options {
    my ($args, $msg, @opts) = @_;
    my %args;

    $msg = "" if (!defined $msg);
    map { $args{$_} = 1 } split(//, $args);
    error("input file option (-i) is mandatory $msg") if (!$opt_in && $args{i});
    error("output file option (-o) is mandatory $msg") if (!$opt_out && $args{o});
    error("package name option (-p) is mandatory $msg") if (!$opt_package && $args{p});
    error("architecture option (-a) is mandatory $msg") if (!$opt_arch && $args{a});
    error("version option (-v) is mandatory $msg") if (!$opt_version && $args{v});

    while (@opts) {
	my $val = shift @opts;
	my $msg = shift @opts;
	error($msg) if (!$val);
    }
    return 1;
}

############### Common subroutines #################
sub regular_print {
    my $msg = shift;
    print STDERR sprintf($msg, @_), "\n";
}

sub verbose_print {
    regular_print(@_) if $opt_verbose;
}

sub find_package_symbolfile_path {
    my ($package, $arch) = @_;
    my @PATHS = (
	"debian/$package.symbols.$arch",
	"debian/symbols.$arch",
	"debian/$package.symbols",
	"debian/symbols"
    );
    for my $path (@PATHS) {
	return $path if (-f $path);
    }
    return undef;
}

sub out_symfile {
    my ($symfile, %opts) = @_;
    return 1 unless $symfile;

    if ($opt_out) {
	$symfile->save($opt_out, template_mode => 1, with_deprecated => 1, %opts);
    } else {
	$symfile->dump(*STDOUT, template_mode => 1, with_deprecated => 1, %opts);
    }
    return 0;
}

sub tweak_symbol {
    my $sym = shift;
    $sym->handle_min_version($opt_version);
}

sub print_changes_list {
    my ($changes, $header, $print_header_sub, $print_sub) = @_;

    if (@$changes) {
	&$print_header_sub($header);
	foreach my $info (@$changes) {
	    if ($info =~ /^\s/) {
		    # Symbol
		    &$print_sub(" %s", $info);
	    } else {
		# Soname
		&$print_sub(" SONAME: %s", $info);
	    }
	}
    }
}

############### Subcommands ####################
sub _create_symfile {
    my ($file, $filename_re) = @_;
    my $filename = File::Basename::basename($file);
    my $symfile;
    if ($filename =~ $filename_re) {
	regular_print("* Loading \"%s\" symbol file '%s' ...", $1, $file);
	$symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(
		file => $file,
		arch => "$1"
	);
    } else {
	warning("%s is not named properly. Expected *_<arch> or *.<arch>", $file);
    }
    return $symfile;
}

sub subcommand_create {
    my @opt_dirs;
    my %opts = (
	get_common_options("oav"),
	"directory|d=s" => \@opt_dirs,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("", "",
	    scalar(@opt_dirs), "symbol file directory option (-d) is mandatory");

	# Load symbol files
	my %symfiles;
	my $str_arches = join("|", get_valid_arches());
	my $filename_re = qr/.*?[_.]($str_arches)$/;
	for my $f (@opt_dirs) {
	    if (-d $f) {
		opendir(DIR, $f) or error("unable to open directory: $f");
		while (my $filename = readdir(DIR)) {
		    next if ($filename =~ /^.{1,2}$/);
		    my $file = File::Spec->catfile($f, $filename);
		    if (my $symfile = _create_symfile($file, $filename_re)) {
			if (exists $symfiles{$symfile->get_arch()}) {
			    error("duplicate symbol file (%s) for arch %s", $file,
				$symfile->get_arch());
			}
			$symfiles{$symfile->get_arch()} = $symfile;
		    }
		}
		closedir DIR;
	    } elsif (-r $f) {
		if (my $symfile = _create_symfile($f, $filename_re)) {
		    if (exists $symfiles{$symfile->get_arch()}) {
			error("duplicate symbol file (%s) for arch (%s)", $f,
			    $symfile->get_arch());
		    }
		    $symfiles{$symfile->get_arch()} = $symfile;
		}
	    } else {
		error("unreadale file/directory: %s", $f);
	    }
	}

	if (scalar(keys %symfiles) > 0) {
	    unless (exists $symfiles{$opt_arch}) {
		error("symbol file for the specified arch (%s) could not be found/loaded. ".
		      "Please specify another arch with -a option", $opt_arch);
	    }
	    # Set confirmed version
	    unless ($opt_version) {
		$opt_version = $symfiles{$opt_arch}->get_highest_version();
	    }
	    foreach my $symfile (values %symfiles) {
		$symfile->set_confirmed($opt_version, $symfile->get_arch());
	    }

	    # Create collection and generate template
	    my $orig_symfile = $symfiles{$opt_arch}->fork_empty();
	    my $symfiles = Debian::PkgKde::SymbolsHelper::SymbolFileCollection->new($orig_symfile);
	    $symfiles->add_new_symfiles(values %symfiles);

	    # Detect templinst symbols before substitutions and create template
	    regular_print("Generating symbol file template .... (this might take a while)");
	    foreach my $symfile ($symfiles->get_symfiles()) {
		foreach my $sym ($symfile->get_symbols()) {
		    $sym->mark_cpp_templinst_as_optional();
		}
	    }
	    my $template = $symfiles->create_template();

	    # Set confirmed header
	    $template->set_confirmed($symfiles->get_latest_version(),
		$symfiles->get_latest_arches());

	    foreach my $soname ($template->get_sonames()) {
		foreach my $sym ($template->get_symbols($soname),
		                 $template->get_soname_patterns($soname))
		{
		    tweak_symbol($sym);
		}
	    }

	    return out_symfile($template);
	} else {
	    error("no properly named symbol files located");
	}
	return 0;
    }
    return 1;
}

sub subcommand_patch {
    my @opt_diffs;
    my $opt_base;
    my %opts = (
	get_common_options("oipavV"),
	"diff|d=s" => \@opt_diffs,
	"base|b=s" => \$opt_base,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("p", "");
	unless ($opt_in) {
	    $opt_in = find_package_symbolfile_path($opt_package, $opt_arch);
	    error("symbol template file was not found for package '$opt_package'")
		unless (defined $opt_in && -r $opt_in);
	}
	$opt_base = $opt_in unless $opt_base;
	push @opt_diffs, "-" unless @opt_diffs;

	# Load input symfile
	my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(
	    file => $opt_in, arch => $opt_arch
	);
	my $version = $symfile->get_confirmed_version();
	unless ($version) {
	    error("multipatch needs a symbol file template with 'SymbolsHelper-Confirmed' header");
	}
	if ($opt_version && version_compare($opt_version, $version) < 0) {
	    error("you specified lower version (%s) than one of the input symbol file template (%s)",
		$opt_version, $version);
	}
	my $base_symfile = $symfile;
	if ($opt_base ne $opt_in) {
	    $base_symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(
		file => $opt_base, arch => $opt_arch
	    );
	}

	# Load patches. Take only those for our package
	my @patches;
	sub grep_patches {
	    my @patches;
	    foreach my $patch (@_) {
		if (!$patch->has_info()) {
		    verbose_print("* patch '%s' discarded due to absence of the info header",
			$patch->get_name());
		    next;
		}
		if ($patch->{package} eq $opt_package) {
		    push @patches, $patch;
		}
	    }
	    return @patches;
	};
	for my $f (@opt_diffs) {
	    if (-d $f) {
		opendir(DIR, $f) or error("unable to open directory with patches: $f");
		while (my $filename = readdir(DIR)) {
		    next if ($filename =~ /^.{1,2}$/);
		    my $file = File::Spec->catfile($f, $filename);
		    push @patches, grep_patches(parse_patches_from_file($file));
		}
		closedir DIR;
	    } elsif (-r $f) {
		push @patches, grep_patches(parse_patches_from_file($f));
	    } elsif ($f eq "-") {
		push @patches, grep_patches(parse_patches_from_handle(\*STDOUT));
	    }
	}

	# Patch the base template with our patches and pick symbol files with
	# the highest version for each architecture.
	my (%psymfiles, %pversions);
	if (@patches) {
	    regular_print("Patching symbol file '%s' with supplied patches ...",
		$base_symfile->{file});
	    my @psymfiles = $base_symfile->patch_template(@patches);
	    foreach my $patch (@patches) {
		my $arch = $patch->{arch};
		my $str = sprintf("* patch '%s' for %s ... ",
		    $patch->get_name(), $arch);
		if ($patch->is_applied() && $psymfiles[0]->get_arch() eq $arch) {
		    regular_print($str . "OK.");

		    my $psymfile = shift @psymfiles;
		    if (!exists $pversions{$arch} ||
			version_compare($patch->{version}, $pversions{$arch}) > 0)
		    {
			$psymfiles{$arch} = $psymfile;
			$pversions{$arch} = $patch->{version};
		    }
		} else {
		    warning($str . "FAILED.");
		    info("the patch has been ignored. Failure output below:\n" .
			$patch->get_apply_output());
		}
	    }
	}
	unless (keys %psymfiles) {
	    error("no valid symbol files could be loaded from the supplied patch files");
	}

	# Reset version if requested and drop patched symbol files which have
	# lower version than original one
	foreach my $arch (keys %psymfiles) {
	    my $psymfile = $psymfiles{$arch};
	    if ($opt_version) {
		$psymfile->set_confirmed($opt_version, $psymfile->get_confirmed_arches());
	    }
	    my $pver = $psymfile->get_confirmed_version();
	    if (version_compare($pver, $version) < 0) {
		warning("ignoring obsolete %s symbol file (its version (%s) < original (%s))",
		    $arch, $pver, $version);
		delete $psymfiles{$arch};
		delete $pversions{$arch};
	    }
	}
	error("no valid patched symbol files found") unless keys %psymfiles;

	# Fork $orig symbol file for the rest (unpatched) confirmed arches.
	my @carches = grep { ! exists $psymfiles{$_} } $symfile->get_confirmed_arches();

	# Finally create a SymbolFile collection and generate template
	my $symfiles = new Debian::PkgKde::SymbolsHelper::SymbolFileCollection($symfile);
	$symfiles->add_new_symfiles(values %psymfiles);
	$symfiles->add_confirmed_arches(@carches);

	# Detect templinst symbols before substitutions and create template
	regular_print("Generating symbol file template .... (this might take a while)");
	foreach my $arch ($symfiles->get_new_arches()) {
	    my $symfile = $symfiles->get_symfile($arch);
	    foreach my $sym ($symfile->get_symbols()) {
		$sym->mark_cpp_templinst_as_optional();
	    }
	}
	my $template = $symfiles->create_template()->fork();

	# Post process template and print various information about result
	my (@changes_new, @changes_lost, @changes_arch);
	foreach my $soname (sort $template->get_sonames()) {
	    push @changes_new, $soname;
	    push @changes_lost, $soname;
	    push @changes_arch, $soname;
	    foreach my $sym (sort { $a->get_symboltempl() cmp $b->get_symboltempl() }
	                           $template->get_symbols($soname),
	                           $template->get_soname_patterns($soname))
	    {
		my $osym = $symfile->get_symbol_object($sym, $soname);
		if (defined $osym) {
		    if ($sym->{deprecated} && ! $osym->{deprecated}) {
			push @changes_lost, " ".$sym->get_symbolspec(1);
		    } elsif (! $sym->{deprecated} && $osym->{deprecated}) {
			# Tweak symbol
			tweak_symbol($sym);
			push @changes_new, " ".$sym->get_symbolspec(1);
		    } else {
			my $arches = $sym->get_tag_value("arch") || '';
			my $oarches = $osym->get_tag_value("arch") || '';

			if ($arches ne $oarches) {
			    push @changes_arch,
				" ".$sym->get_symbolspec(1)." (was arch=$oarches)";
			}
		    }
		} else {
		    # Tweak symbol
		    tweak_symbol($sym);
		    push @changes_new, " ".$sym->get_symbolspec(1);
		}
	    }
	    # Pop sonames if no symbols added
	    pop @changes_new if $changes_new[$#changes_new] eq $soname;
	    pop @changes_lost if $changes_lost[$#changes_lost] eq $soname;
	    pop @changes_arch if $changes_arch[$#changes_arch] eq $soname;
	}

	print_changes_list(\@changes_new,
	    "there are NEW symbols (including optional):",
	    \&info, \&verbose_print) if $opt_verbose;
	print_changes_list(\@changes_lost,
	    "there are LOST symbols (including optional):",
	    \&warning, \&regular_print);
	print_changes_list(\@changes_arch,
	    "architecture set changed for the symbols below:",
	    \&info, \&regular_print);

	# Finally adjust confirmed arches list
	$template->set_confirmed($symfiles->get_latest_version(),
	    $symfiles->get_latest_arches());

	# Generate diff
	if ($opt_verbose) {
	    my $tmpfile = File::Temp->new(TEMPLATE => "${opt_in}.newXXXXXX");
	    $template->dump($tmpfile,
		package => $opt_package,
		template_mode => 1,
		with_deprecated => 1,
	    );
	    $tmpfile->close();
	    fork_and_exec(exec => ["diff", "-u", $symfile->{file}, $tmpfile->filename],
		to_handle => \*STDERR, wait_child => 1, nocheck => 1);
	}

	return out_symfile($template);
    }
    return 1;
}

#sub subcommand_patch {
#    my $opt_diff;
#    my %opts = (
#	get_common_options("oipav"),
#	"diff|d=s" => \$opt_diff,
#    );
#    if (GetOptions(%opts)) {
#	check_mandatory_options("i", "when package (-p) is not specified") unless ($opt_package);
#	unless ($opt_in) {
#	    $opt_in = find_package_symbolfile_path($opt_package, $opt_arch);
#	    error("symbol template file was not found for package '$opt_package'")
#		unless (defined $opt_in && -r $opt_in);
#	}
#	$opt_out = $opt_in if (!$opt_out && -w $opt_in);
#	$opt_diff = "-" unless ($opt_diff);
#
#	# Open patch
#	open(DIFFINPUT, $opt_diff)
#	    or error("unable to open patch '$opt_diff' for reading");
#
#	my $orig_symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(
#	    file => $opt_in, arch => $opt_arch);
#	my $patched_symfile = patch_symbolfile($opt_in, *DIFFINPUT);
#
#	# Read remaning $patchfh stream
#	if ($opt_diff eq "-") {
#	    while (<DIFFINPUT>) {}
#	}
#	close(DIFFINPUT);
#
#	error("supplied patch does not apply to the symbols file '$opt_in'")
#	    unless defined $patched_symfile;
#
#	foreach my $info ($patched_symfile->get_new_symbols($orig_symfile)) {
#	    # Retrieve real symbol instance
#	    my $sym = $patched_symfile->{objects}{$info->{soname}}{syms}{$info->get_symbolname()};
#	    $sym->mark_cpp_templinst_as_optional();
#	    tweak_symbol($sym);
#
#	    info("NEW symbol: " . $sym->get_symbolspec(1));
#	}
#	return out_symfile($patched_symfile);
#    }
#    return 1;
#}

sub subcommand_rewrite {
    my $opt_template = 1;
    my $opt_convert;
    my %opts = (
	get_common_options("oia"),
	"template!" => \$opt_template,
	"convert" => \$opt_convert,
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i");

	if (-f $opt_in) {
	    my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(file => $opt_in, arch => $opt_arch);
	    my %o = (
		template_mode => $opt_template
	    );

	    if ($opt_convert) {
		foreach my $soname ($symfile->get_sonames()) {
		    foreach my $sym ($symfile->get_symbols($soname)) {
			$sym->upgrade_virtual_table_symbol($opt_arch);
			tweak_symbol($sym);
		    }
		}
	    }

	    return out_symfile($symfile, %o);
	} else {
	    error("input symbol file ($opt_in) not found");
	    return 1;
	}
    }
    return 1;
}

sub subcommand_symbolfile {
    warning("'symbolfile' and debian/*.symbols.in files have been deprecated.");
    info("You should add substitutions to standard symbol files and " .
         "use pkgkde-gensymbols as dpkg-gensymbols wrapper.");
    my %opts = (
	get_common_options("oipa"),
    );
    if (GetOptions(%opts)) {
	check_mandatory_options("i", "when package (-p) is not specified") unless ($opt_package);
	unless ($opt_in) {
	    $opt_in = "debian/$opt_package.symbols.in";
	    error("symbol template file '$opt_in' was not found for package '$opt_package'") unless (-r $opt_in);
	}
	# Redump to new location.
	my $symfile = Debian::PkgKde::SymbolsHelper::SymbolFile->new(file => $opt_in, arch => $opt_arch);
	foreach my $sym ($symfile->get_symbols()) {
	    if ($sym->has_tag("subst")) {
		my $val = $sym->get_tag_value("subst");
		if (defined $val && $val eq "compat") {
		    # Reset symbol template to current name value
		    $sym->set_symbolname();
		    $sym->delete_tag("subst");
		}
	    }
	}
	return out_symfile($symfile);
    }
    return 1;
}

sub subcommand_postgensymbols {
    warning("postgensymbols has been deprecated. Please remove this call.");
    return 0;
}

# Boilerplate for the common subcommand handler
sub subcommand_boilerplate {
    my %opts = (
	get_common_options("oipav"),
    );
    if (GetOptions(%opts)) {
#	 check_mandatory_options("o");
	return 0;
    }
    return 1;
}

my %SUBCOMMANDS = (
    "create"		=> [ 1, \&subcommand_create, "create symbol file template" ],
    "patch"		=> [ 2, \&subcommand_patch, "apply dpkg-gensymbols patch(es) to the symbol file template" ],
    "rewrite"		=> [ 3, \&subcommand_rewrite, "filter/rewrite symbol file" ],
    "symbolfile"	=> [ 4, \&subcommand_symbolfile, "deprecated by pkgkde-gensymbols wrapper" ],
    "postgensymbols"	=> [ 5, \&subcommand_postgensymbols, "deprecated. Does nothing" ],
);

report_options(info_fh => \*STDERR);

my $curcmd = shift @ARGV;
if (defined $curcmd && exists $SUBCOMMANDS{$curcmd}) {
    my $ret = &{$SUBCOMMANDS{$curcmd}->[1]}();
    exit($ret);
} else {
    my $err;
    $err = ($curcmd) ? "unrecognized subcommand '$curcmd'." : "subcommand was not specified.";
    errormsg($err . " Valid subcommands are:");

    for my $cmd (sort({ $SUBCOMMANDS{$a}->[0] <=> $SUBCOMMANDS{$b}->[0] }
		 keys %SUBCOMMANDS)) {
	# Display command and its short help
	info("	$cmd - " . $SUBCOMMANDS{$cmd}->[2]);
    }
    exit(2);
}
